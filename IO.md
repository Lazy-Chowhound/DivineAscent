[toc]

# *BIO* (同步阻塞 *IO*)

> 线程发起 *IO* 请求，不管内核是否准备好 *IO* 操作，从发起请求起，线程一直阻塞，直到操作完成。

# *NIO* (同步非阻塞 *IO*)

> 客户端发送的连接请求都会注册到多路复用器 (*Selector*) 上，多路复用器轮询到连接有 *I/O* 请求时才启动一个线程进行处理。

# *AIO*

> 线程发起 *IO* 请求，立即返回；内存做好 *IO* 操作的准备之后，做 *IO* 操作，直到操作完成或者失败，通过调用注册的回调函数通知线程做 *IO* 操作完成或者失败。

# 五种 *IO* 模型

## 阻塞 *IO*

当有 *IO* 请求时，从开始到内核准备好数据再到把数据从内核拷贝到用户区，这段时间里程序是阻塞的。

## 非阻塞 *IO*

与阻塞 *IO* 的区别在于，有 *IO* 请求之后到内核准备好数据之前这段时间里程序会不断轮询去询问内核数据是否准备好，当有数据报准备好时，就进行拷贝数据报的操作。当没有数据报准备好时，也不阻塞程序，内核直接返回未准备就绪的信号，等待程序的下一个轮询。

## 信号驱动 *IO*

在 *IO* 请求到来之后，进程并不阻塞，当内核准备数据之后会发送 *SIGIO* 信号给程序，然后程序将数据从内核拷贝到用户区，这段时间程序是阻塞的。

## *IO* 多路复用

相比于阻塞 *IO*，该方式多了个 *select* 函数，一个线程内同时处理多个*IO*请求，当有 *IO* 准备好时就将数据从内核拷贝到用户空间，此种方式可以同时处理多个*IO*。

## 异步 *IO*

从开始到内核准备好数据再到把数据从内核拷贝到用户区，这段时间里程序是继续进行的。

# *select*、*poll* 和 *epoll*

## *select*

​	*select()* 的机制中提供一种 *fd_set* 的数据结构，实际上是一个 *long* 类型的数组，每一个数组元素都能与一打开的文件句柄（不管是*Socket* 句柄,还是其他文件或命名管道或设备句柄）建立联系。由内核根据 *IO* 状态修改 *fd_set* 的内容，由此来通知执行了 *select()* 的进程哪一 *socket* 或文件可读。

​	使用 *select* 以后最大的优势是用户可以在一个线程内同时处理多个 *socket* 的 *IO* 请求。用户可以注册多个 *socket*，然后不断地调用 *select* 读取被激活的 *socket*，即可达到在同一个线程内同时处理多个 *IO* 请求的目的。而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。

### *select*机制的问题

​	每次调用 *select*，都需要把 *fd_set* 集合从用户态拷贝到内核态，如果 *fd_set* 集合很大时，那这个开销也很大

​	为了减少数据拷贝带来的性能损坏，内核对被监控的 *fd_set* 集合大小做了限制，并且这个是通过宏控制的，大小限制为1024。

## *poll*

​	*poll* 的机制与 *select* 类似，与 *select* 在本质上没有多大差别，管理多个描述符也是进行轮询，根据描述符的状态进行处理，但是 *poll* 没有最大文件描述符数量的限制

## *epoll*

​	*epoll* 在 *Linux*2.6 内核正式提出，是基于事件驱动的 *I*/*O* 方式，相对于 *select* 来说，*epoll* 没有描述符个数限制，使用一个文件描述符管理多个描述符，将用户关心的文件描述符的事件存放到内核的一个事件表中，这样在用户空间和内核空间的 *copy* 只需一次。

​	事件通知方式，每当 *fd* 就绪，系统注册的回调函数就会被调用，将就绪 *fd* 放到 *readyList* 里面，*epoll*_*wait* 此时收到通知，成功时返回就绪的 *fd* 列表

​	*LT* 模式，也叫做水平触发模式。在该模式下，当有 *I/O*事件发生并调用 *epoll__wait* 后，若未及时处理，下一次调用 *epoll_wait* 仍会继续通知。

​	*ET* 模式，也叫边缘触发模式，与水平模式的区别就是，若未及时处理，之后调用 *epoll_wait* 不会再次通知，直到该文件描述符上出现新的可读写事件才会通知你。
