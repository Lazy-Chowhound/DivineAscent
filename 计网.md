 [TOC]

# *OSI*七层模型和*TCP/IP*五层模型

## *OSI*七层模型

​	物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

## *TCP/IP五层模型*

​	物理层、数据链路层、网络层、传输层、应用层

# *TCP* 和 *UDP*

​	*TCP* 面向连接，可靠，基于字节流，而 *UDP* 不面向连接，不可靠，基于数据报。

## 区别

1. *tcp*是基于连接的，可靠性高；*udp*是基于无连接的，可靠性较低；

2. *tcp* 报头20字节；*udp* 首部开销只有8个字节，*tcp* 报头比 *udp* 复杂，故实际包含的用户数据较少。*tcp* 开销大，*udp*开销较小；

3. *tcp* 保证数据顺序，*udp* 不保证 ;

   对数据传输的完整性、正确性有较高要求则使用 *tcp*，如果对实时性有要求则使用 *udp*（如视频）

## 补充：*TCP* 如何保持连接

​	当网络两端建立了 *tcp* 连接之后，闲置（双方没有任何数据流发送往来）了 *tcp*_*keepalive*_*time* 后，服务器就会尝试向客户端发送侦测包，来判断 *tcp* 连接状况(有可能客户端崩溃、强制关闭了应用、主机不可达等等)。如果没有收到对方的回答(*ack*包)，则会在 *tcp*_keepalive_*intvl* 后再次尝试发送侦测包，直到收到对方的 *ack*,如果一直没有收到对方的*ack*,一共会尝试 *tcp*_*keepalive*_*probes* 次，每次的间隔时间在这里分别是15*s*, 30*s*, 45*s*, 60*s*, 75*s*。如果尝试*tcp*_*keepalive*_*probes*,依然没有收到对方的 *ack* 包，则会丢弃该 *tcp* 连接。

 # 三次握手

> 1. 第一次握手：客户端给服务器发送一个 *SYN* 报文。
>
> 2. 第二次握手：服务器收到 *SYN* 报文之后，会应答一个 *SYN*+*ACK* 报文。
>
> 3. 第三次握手：客户端收到 *SYN*+*ACK* 报文之后，会回应一个 *ACK* 报文。
>
> 4. 服务器收到 *ACK* 报文之后，三次握手建立完成。

​	为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手

​	假设只有两次握手，当*A*想要建立连接时发送一个 *SYN*，然后等待 *ACK*，结果这个 *SYN* 因为网络问题没有及时到达 *B*，所以 *A* 在一段时间内没收到 *ACK* 后，在发送一个 *SYN*，*B* 也成功收到，然后 *A* 也收到 *ACK*，这时 *A* 发送的第一个 *SYN* 终于到了 *B*，对于 *B* 来说这是一个新连接请求，然后 *B* 又为这个连接申请资源，返回 *ACK*，然而这个 *SYN* 是个无效的请求，*A*收到这个 *SYN* 的 *ACK* 后也并不会理会它，而 *B* 却不知道，*B* 会一直为这个连接维持着资源，造成资源的浪费

​	那三次握手为什么可以？两次握手的问题在于服务器端不知道一个 *SYN* 是否是无效的，而三次握手机制因为客户端会给服务器回复第二次握手，也意味着服务器会等待客户端的第三次握手，如果第三次握手迟迟不来，服务器便会认为这个 *SYN* 是无效的，释放相关资源。但这时有个问题就是客户端完成第二次握手便认为连接已建立，而第三次握手可能在传输中丢失，服务端会认为连接是无效的，这时如果 *Client* 端向 *Server* 写数据，*Server* 端将以 *RST* 包响应，方能感知到*Server* 的错误。

# 四次挥手

1. 第一次挥手：客户端发送一个 *FIN* 报文，报文中会指定一个序列号。此时客户端处于*FIN*_*WAIT*1状态。

2. 第二次握手：服务端收到 *FIN* 之后，会发送 *ACK* 报文，且把客户端的序列号值 +1 作为 *ACK* 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 *CLOSE*_*WAIT* 状态。

3. 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 *FIN* 报文，且指定一个序列号。此时服务端处于 *LAST*_*ACK* 的状态。

4. 第四次挥手：客户端收到 *FIN* 之后，一样发送一个 *ACK* 报文作为应答，且把服务端的序列号值 + 1 作为自己 *ACK* 报文的序列号值，此时客户端处于 *TIME*_*WAIT* 状态。需要过一阵子以确保服务端收到自己的 *ACK* 报文之后才会进入 *CLOSED* 状态

5. 服务端收到 *ACK* 报文之后，就处于关闭连接了，处于 *CLOSED* 状态。

 ## *TIME*_*WAIT*

​	*TIME*_*WAIT* 这个状态了，这个是面试的高频考点，就是要理解，为什么客户端发送 *ACK* 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，要确保服务器是否已经收到了我们的 *ACK* 报文，如果没有收到的话，服务器会重新发 *FIN* 报文给客户端，客户端再次收到 *ACK* 报文之后，就知道之前的 *ACK* 报文丢失了，然后再次发送 *ACK* 报文。

# 为什么建立连接是三次，而关闭连接却是四次？

​	这是因为建立连接时，服务端收到 *SYN* 报文的建连请求后，它可以把 *ACK* 和 *SYN*（*ACK* 起应答作用，而 *SYN* 起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的 *FIN* 报文通知时，它仅仅表示对方没有数据发送给你了，但是你还可以给对方发送数据，或者也可能你还有一些数据在传给对方的途中，所以你不能立马关闭连接,也即你可能还需要把在传输途中的数据给对方之后，又或者你还有一些数据需要传输给对方后（再关闭连接）再发送*FIN* 报文给对方来表示你同意现在可以关闭连接了，所以它这里的 *ACK* 报文和 *FIN* 报文多数情况下都是分开发送的。

# *http* 如何实现可靠传输

## *ACK* 和超时重传

*TCP* 每发送一个数据报，都会期待一个接收端 *ACK* 的回复，我们就知道接收端已经收到消息了。如果短时间内没有收到 *ACK*，那么 *TCP*  就会对消息进行自动重发。

未收到 *ACK* 就说明消息一定就丢了吗？也不一定，有可能接收端收到消息了，返回 *ACK* 的途中发生了丢失。这个时候这个时候依然会进行超时重发。接收端可能会收到同样的消息，没关系我们不是对发送的数据进行编号了吗，如果接收端收到重复消息直接丢失就可以了。

## 滑动窗口

[*TCP*滑动窗口 ](https://blog.csdn.net/wdscq1234/article/details/52444277)

## 拥塞控制

[*TCP*拥塞控制](https://blog.csdn.net/qq_41431406/article/details/97926927)

# *Socket*和*WebSocket*

## *Http* 和 *WebSocket* 的区别

​	*http* 协议是短链接，因为请求之后，都会关闭连接，下次请求需要重新打开链接。

​	*websocket* 协议是一种长连接，只需要通过一次请求来初始化连接，然后所有请求和响应都是通过 *TCP* 链接进行通信。

## *WebSocket* 和 *Socket* 的区别？

​	*socket* 是应用层与 *TCP*/*IP* 协议通信的中间软件抽象层，它是一组接口。

​	而 *websocket* 协议是一个完整的应用层协议，拥有一套完整的 *API*，允许服务器向客户端传递信息，实现浏览器和客户端双工通信。

# *Session* 和 *Cookies*

## *Cookie*

​    *Cookie* 实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用 *response* 向客户端浏览器发一个*Cookie*。客户端浏览器会把 *Cookie* 保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该 *Cookie* 一同提交给服务器。服务器检查该 *Cookie*，以此来辨认用户状态。服务器还可以根据需要修改 *Cookie* 的内容。

## *Session*

​	打开新的浏览器窗口会生成新的 *Session*，但子窗口除外，子窗口会共用父窗口的 *Session*，例如，在链接上右击，在弹出的快捷菜单中选择“在新窗口中打开”时，子窗口便可以访问父窗口的*Session*。

　*URL*地址重写是对客户端不支持 *Cookie* 的解决方案。*URL* 地址重写的原理是将该用户 *Session*的*id*信息重写到 *URL* 地址中。服务器能够解析重写后的 *URL* 获取 *Session* 的 *id*。这样即使客户端不支持 *Cookie*，也可以使用 *Session* 来记录用户状态。

使用 *Session* 维护用户登录状态的过程如下：

>  用户进行登录时，用户提交包含用户名和密码的表单，放入 *HTTP* 请求报文中；
>
> 服务器验证该用户名和密码，如果正确则把用户信息存储到 *Redis* 中，它在 *Redis* 中的 *Key* 称为 *Session* *ID*；
>
> 服务器返回的响应报文的 *Set*-*Cookie* 首部字段包含了这个 *Session* *ID*，客户端收到响应报文之后将该 *Cookie* 值存入浏览器中；
>
> 客户端之后对同一个服务器进行请求时会包含该 *Cookie* 值，服务器收到之后提取出 *Session* *ID*，从 *Redis* 中取出用户信息，继续之前的业务操作。

# *HTTP*状态码

100 *Continue* 客户端事先发送一个只带头域的请求。100 (*Continue*) 状态代码的使用，允许客户端在发 *request* 消息 *body* 之前先用 *request* *header* 试探一下 *server*，看 *server* 要不要接收 *request* *body*，再决定要不要发 *request* *body*。

---

200 *OK* 请求成功。

201 *Created* 已创建 成功请求并创建了新的资源

202 *Accepted* 已接受 已经接受请求，但未处理完成

---

300 与重定向有关

301 *Moved Permanently* 资源被永久移动到其他 *URI*，返回新的 *URI* 并重定向到新 *URI*

302 *Moved Temporarily* 资源被暂时移动到其他，应使用原来的 *URI*

---

400 *Bad* *Request*  客户端请求的语法错误，服务器无法理解

401 *Unauthorized* 请求要求用户的身份认证

403 *Forbidden*   服务器理解请求客户端的请求，但是拒绝执行此请求

404 *Not* *Found*   服务器无法根据客户端的请求找到资源（网页）。

405 *Method* *Not* *Allowed*   客户端请求中的方法被禁止

---

500 *Internal* *Server* *Error* 服务器内部错误，无法完成请求

501 *Not* *Implemented*  服务器不支持请求的功能，无法完成请求

502 *Bad* *Gateway* 作为网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应

503 *Service* *Unavailable* 由于超载或系统维护，服务器暂时无法处理请求。

# *Put* 和 *Post* 的区别

*put* 是幂等的操作，10次 *put* 请求与1次 *put* 请求相同，只会创建一个资源，其实后面9次的请求只是对已创建资源的更新，且更新内容与原内容相同，所以不会产生变化。

*post* 的重复操作截然不同，10次 *post* 请求将会创建10个资源。

 # *Options* 预请求和 *Head* 请求

*options* 预请求要求必须先发送一个 *options* 请求给目的站点，来查明这个跨站请求的站点或者方法（*get*、*post*）是否能被目的站点接受。这样做，是因为跨站请求可能会对目的站点的数据造成破坏。

使用 *options* 预请求的情况：

1. 使用自定义头
2. 简单请求，比如使用 *Content-Type* 为 *application/xml* 或 *text/xml* 的 *post* 请求

*head* 请求与 *get* 类似，但是 *head* 并不返回消息体。在一个 *head* 请求的消息响应中，*http* 头中包含的元信息应该和一个 *get* 请求的响应消息相同。这种方法可以用来获取请求中隐含的元信息，而无需传输实体本身。这个方法经常用来测试超链接的有效性和资源的有效性。 

# 跨域

当一个请求*url*的**协议、域名、端口**三者之间任意一个与当前页面不同即为跨域

## *CORS*

*CORS* 是跨域资源分享，是跨源 *Ajax* 请求的根本解决方法。

1、普通跨域请求：只需服务器端设置 *Access-Control-Allow-Origin*

2、带 *cookie* 跨域请求：前后端都需要进行设置

 # *HTTP* 请求报文和响应报文

## 请求报文

​    请求行：请求方法 请求的 *URL* 协议及其版本

​    请求头：请求的主机名和端口*host*、请求来源 *origin*、请求的原始*UrlReferer*、*User-Agent*、*Accept-Encoding*、*Accept-Language*、*Content-Type*

​    请求体：相关数据

 ## 响应报文

​    响应行：协议及其版本 状态码

​    响应头：*Access*-*Control*-*Allow*-*Origin*、*Access*-*Control*-*Allow*-*Methods*、*Content*-*Type*、*Content*-*Length*

​    实体：返回的数据

# *Http*1.0 和 *Ht*tp2.0的区别

## 多路复用

​	*Http*2.0 使用了多路复用的技术，做到同一个连接并发处理多个请求，

## *Header*压缩

​	在 *Http* 1.1中，*Http* 请求和响应都是由状态行、请求/响应头部、消息主体三部分组成。一般而言，消息主体都会经过压缩，但状态行和头部却没有经过任何压缩，直接以纯文本传输。随着请求数越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输 *User-Agent*、*Cookie*这类不会频繁变动的内容，完全是一种浪费。

​	*Http*1.1不支持 *header* 数据的压缩，*Http*2.0 使用 *Hpack* 算法对 *header* 的数据进行压缩，这样数据体积小了，在网络上传输就会更快

## 服务器推送

​	网页使用了许多资源：*Html*、*Css*、*Js* 等等。在 *Http*1.1 中这些资源每一个都必须明确地请求。这是一个很慢的过程，因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的。

​	*Http*2.0 引入了 *server push*，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。

# *Http* 缓存

## 强制缓存

![image-20210729195123729](/picture/强制缓存.png)

## 对比缓存

![image-20210729195237682](/picture/对比缓存.png)

## 缓存验证

需要先了解 *ETag* 首部字段的含义，它是资源的唯一标识。*Url* 不能唯一表示资源，例如 *http://www.google.com/* 有中文和英文两个资源，只有 *ETag* 才能对这两个资源进行唯一标识。

可以将缓存资源的 *ETag* 值放入 *If-None-Match* 首部，服务器收到该请求后，判断缓存资源的 *ETag* 值和资源的最新 *ETag* 值是否一致，如果一致则表示缓存资源有效，返回 304 *Not* *Modified*。

*Last-Modified* 首部字段也可以用于缓存验证，它包含在源服务器发送的响应报文中，指示源服务器对资源的最后修改时间。但是它是一种弱校验器，因为只能精确到一秒，所以它通常作为 *ETag* 的备用方案。如果响应首部字段里含有这个信息，客户端可以在后续的请求中带上 *If-Modified-Since* 来验证缓存。服务器只在所请求的资源在给定的日期时间之后对内容进行过修改的情况下才会将资源返回，状态码为 200 *OK*。如果请求的资源从那时起未经修改，那么返回一个不带有实体主体的 304 *Not* *Modified* 响应报文。

 # *Restful Api*

> *REST*，表示性状态转移（*representation state transfer*）。简单来说，就是用 *URI* 表示资源，用 *Http*方法(*Get*, *Post*, *Put*,*Delete*)表征对这些资源的操作。

- *Resource*：资源，即数据，存在互联网上的可被访问的实体。
- *Representation*：数据的某种表现形式，如*Html*,*Json*。
- *State Transfer*：状态变化，*Http*方法实现。

*Restful API*就是 *REST* 风格的 *API*，要求前端以一种预定义的语法格式发送请求，那么服务端就只需要定义一个统一的响应接口，而无需区分是何种终端发送的请求。

*Restful* 是典型的基于 *http* 的协议。它有哪些设计原则和规范呢？

1. 资源。首先要明确资源就是网络上的一个实体，可以是文本、图片、音频、视频。资源总是以一定的格式来表现自己，如 *Html*，*Jpg* 图片。而 *Json* 是 *Restful API* 中最常用的资源表现格式。

2. 统一接口。对于业务数据的*Crud*，*Restful* 用 *Http* 方法与之对应。

   |  *Crud*  | *Methods* |
   | :------: | :-------: |
   | *Create* |  *Post*   |
   | *Select* |   *Get*   |
   | *Update* |   *Put*   |
   | *Delete* | *Delete*  |

*Uri*，统一资源标识符，它可以唯一标识一个资源；*Url* (统一资源定位符)是一种 *Uri*，可以唯一标志资源，*Url* 是 *Uri* 的子集，*Url* 使用路径来标识资源，还可以用一个唯一编号来标识资源。

> 应该将 *API* 的版本号放入*URL*,如：*https://api.example.com/v1/*
>
> *Api* 应该提供参数，过滤返回结果,如：*?id=5*

3. 无状态。 所谓无状态是指所有资源都可以用 *URI* 定位，而且这个定位与其他资源无关，不会因为其他资源的变动而变化。

在 *Restful* 架构中，每个地址代表一种资源（*resource*），所以 *Url* 中只能有名词，不能出现动词（方法是由 *Http* 请求报文头部给出）。

# 虚拟主机

*Http/1.1* 使用虚拟主机技术，使得一台服务器拥有多个域名，并且在逻辑上可以看成多个服务器

## 代理

代理服务器接受客户端的请求，并且转发给其它服务器。

使用代理的主要目的是：

- 缓存
- 负载均衡
- 网络访问控制
- 访问日志记录

代理服务器分为正向代理和反向代理两种：发送请求的为正向代理，接受请求的为反向代理，反向代理一般位于内部网络之中。

## 网关

与代理服务器不同的是，网关服务器会将 *Http* 转化为其它协议进行通信，从而请求其它非 *Http* 服务器的服务。

## 隧道

使用 *SSL* 等加密手段，在客户端和服务器之间建立一条安全的通信线路。

# *HTTP*和*HTTPS*

*HTTP* 有以下安全性问题：

- 使用明文进行通信，内容可能会被窃听；
- 不验证通信方的身份，通信方的身份有可能遭遇伪装；
- 无法证明报文的完整性，报文有可能遭篡改。

*HTTPS* 并不是新协议，而是让 *HTTP* 先和 *SSL*（*Secure Sockets Layer*）通信，再由 *SSL* 和 *TCP* 通信，也就是说 *HTTPS* 使用了隧道进行通信。

通过使用 *SSL*，*HTTPS* 具有了加密（防窃听）、认证（防伪装）和完整性保护（防篡改）

## 加密

### 对称密钥加密

对称密钥加密，加密和解密使用同一密钥。

- 优点：运算速度快；
- 缺点：无法安全地将密钥传输给通信方

### 非对称密钥加密

非对称密钥加密，加密和解密使用不同的密钥。

公开密钥所有人都可以获得，通信发送方获得接收方的公开密钥之后，就可以使用公开密钥进行加密，接收方收到通信内容后使用私有密钥解密。

非对称密钥除了用来加密，还可以用来进行签名。因为私有密钥无法被其他人获取，因此通信发送方使用其私有密钥进行签名，通信接收方使用发送方的公开密钥对签名进行解密，就能判断这个签名是否正确。

- 优点：可以更安全地将公开密钥传输给通信发送方；
- 缺点：运算速度慢。

### *HTTPS* 采用的加密方式

上面提到对称密钥加密方式的传输效率更高，但是无法安全地将密钥 *Secret Key* 传输给通信方。而非对称密钥加密方式可以保证传输的安全性，因此我们可以利用非对称密钥加密方式将 *Secret Key* 传输给通信方。*Https* 采用混合的加密机制，正是利用了上面提到的方案：

- 使用非对称密钥加密方式，传输对称密钥加密方式所需要的 *Secret Key*，从而保证安全性;
- 获取到 *Secret Key* 后，再使用对称密钥加密方式进行通信，从而保证效率。

![img](/picture/https.jpg)

### 漏洞：中间人攻击

1. 某网站有非对称加密的公钥*A*、私钥*A’*。
2. 浏览器向网站服务器请求，服务器把公钥A明文给传输浏览器。
3. 中间人劫持到公钥*A*，保存下来，把数据包中的公钥*A*替换成自己伪造的公钥*B*（它当然也拥有公钥B对应的私钥*B’*）。
4. 浏览器生成一个用于对称加密的密钥*X*，用公钥*B*（浏览器无法得知公钥被替换了）加密后传给服务器。
5. 中间人劫持后用私钥*B’*解密得到密钥*X*，再用公钥*A*加密后传给服务器。
6. 服务器拿到后用私钥*A’*解密得到密钥*X*。

这样在双方都不会发现异常的情况下，替换了服务器传来的公钥，进而得到了密钥*X*。根本原因是浏览器无法确认收到的公钥是不是网站自己的。

## 认证

通过使用证书来对通信方进行认证。

数字证书认证机构（*CA，Certificate Authority*）是客户端与服务器双方都可信赖的第三方机构。

![CA认证](/picture/CA.png)

**补充：公钥加密，私钥解密 ——用于加解密**

​			**私钥加密，公钥解密 ——用于验证**



# CSRF(跨站请求伪造)

## 原理

 攻击者通过盗用用户身份悄悄发送一个请求，或执行某些恶意操作

1. 首先用户 *C* 浏览并登录了受信任站点 *A*；
2. 登录信息验证通过以后，站点 *A* 会在返回给浏览器的信息中带上已登录的 *cookie*， *cookie*信息会在浏览器端保存一定时间(根据服务端设置而定)；
3. 完成这一步以后，用户在没有登出(清除站点 *A* 的 *cookie*)站点 *A* 的情况下，访问恶意站点 *B*；
4. 这时恶意站点 *B* 的某个页面向站点 *A* 发起请求，而这个请求会带上浏览器端所保存的站点 *A* 的 *cookie*；
5. 站点 *A* 根据请求所带的 *cookie*，判断此请求为用户 *C* 所发送的。

## 危害

- 篡改目标网站上的用户数据；
- 盗取用户隐私数据；
- 作为其他攻击向量的辅助攻击手法；
- 传播 *CSRF* 蠕虫。

## 预防

在发送请求时带上此 *Token*，服务端验证 *Token* 值，如果相匹配才执行相应的操作、销毁原 *Token* 以及生成并返回新的 *Token* 给用户（*cookie* 是请求主动带上的，*token* 需要放在请求主体中 *POST* 过去）

# *XSS* (跨站脚本漏洞)

## 原理

跨站脚本攻击是指恶意攻击者往 *Web* 页面里插入恶意 *Script* 代码，当用户浏览该页之时，嵌入其中 *Web* 里面的 *Script* 代码会被执行，从而达到恶意攻击用户的目的。

一个简单的例子，在输入框内输入`<script>alert('1')</script>`，点击提交，该段代码就会触发，在屏幕上显示1

## 分类

### 反射型 *XSS* <非持久化> 

攻击者事先制作好攻击链接，欺骗用户去点击链接触发 *XSS* 代码。比如在用户登录网站之后，去欺骗用户点击自己制作的攻击链接，然后就可以获取用户的登录信息，如用户名，*cookie* 等

### 存储型 *XSS* <持久化> 

代码是存储在服务器中的，如在个人信息或发表文章等地方，加入代码，如果没有过滤或过滤不严，那么这些代码将储存到服务器中，每当有用户访问该页面的时候都会触发代码执行，这种 *XSS* 非常危险，容易造成蠕虫，大量盗窃 *cookie*。

### *DOM* 型 *XSS*

## 预防

对用户输入进行过滤处理

# 网络层协议

## 地址解析协议 *ARP*

网络层实现主机之间的通信，而链路层实现具体每段链路之间的通信。因此在通信过程中，*IP* 数据报的源地址和目的地址始终不变，而 *MAC* 地址随着链路的改变而改变。*ARP* 实现由 *IP* 地址得到 *MAC* 地址。

每个主机都有一个 *ARP* 高速缓存，里面有本局域网上的各主机和路由器的 *IP* 地址到 *MAC* 地址的映射表。

如果主机 *A* 知道主机 *B* 的 *IP* 地址，但是 *ARP* 高速缓存中没有该 *IP* 地址到 *MAC* 地址的映射，此时主机 *A* 通过广播的方式发送 *ARP* 请求分组，主机 *B* 收到该请求后会发送 *ARP* 响应分组给主机 *A* 告知其 *MAC* 地址，随后主机 *A* 向其高速缓存中写入主机 *B* 的 *IP* 地址到 *MAC* 地址的映射。

## 网际控制报文协议 *ICMP*

*ICMP* 是为了更有效地转发 *IP* 数据报和提高交付成功的机会。它封装在 *IP* 数据报中，但是不属于高层协议。

*ICMP* 报文分为差错报告报文和询问报文。

*Ping* 是 *ICMP* 的一个重要应用，主要用来测试两台主机之间的连通性。

*Ping* 的原理是通过向目的主机发送 *ICMP* *Echo* 请求报文，目的主机收到之后会发送 *Echo* 回答报文。*Ping* 会根据时间和成功响应的次数估算出数据包往返时间以及丢包率。

# 应用层协议

## 动态主机配置协议 *DHCP*

客户机登录服务器时就可以自动获得服务器分配的 *IP* 地址和子网掩码。*DHCP* 配置的内容不仅是 *IP* 地址，还包括子网掩码、网关 *IP* 地址。

## 域名系统*DNS*

迭代查询：当根域名服务器收到本地域名服务器发出的迭代查询请求报文时，要么给出所要查询的 *IP* 地址，要么给出下一步请求的服务器 *IP*。然后让本地服务器进行后续的查询。

递归查询：如果主机所询问的本地域名服务器不知道被查询的域名的 *IP* 地址，那么本地域名服务器就以 *DNS* 客户的身份，向其它根域名服务器继续发出查询请求报文(即替主机继续查询)，而不是让主机自己进行下一步查询。

## 浏览器输入网址后发生什么

1. *Url*解析

   首先判断你输入的是一个合法的 *Url* 还是一个待搜索的关键词，并且根据你输入的内容进行自动完成、字符编码等操作。浏览器还会进行一些额外的操作，比如安全检查、访问限制。检查缓存

2. *Dns*查询

   ![DNS](\picture\DNS.png)

   浏览器会先检查域名对应的 *IP* 是否在缓存中，没有则检查域名是否存在本地的 *Hosts* 文件里，没有则向本地 *DNS* 服务器发送查询请求，如果本地 *DNS* 服务器也没有，本地 *DNS* 就向根*DNS*服务器发送请求，根 *DNS* 服务器收到请求后会返回顶级域名服务器 *IP*。本地 *DNS* 服务器收到 *IP* 信息后，向该顶级域名 *DNS* 服务器发送请求，如果该服务器无法解析，则会返回域服务器地址，本地 *DNS* 服务器拿到后就去请求该域服务器，域服务器返回对应的*IP*。本地服务器拿到 *IP* 后就返回会给客户端

3. *Tcp*链接

4. 处理请求

5. 接受响应

   浏览器接收到来自服务器的响应资源后，会对资源进行分析，对响应资源做缓存。

   接下来，根据响应资源里类型去解析相应内容。

6. 渲染页面
