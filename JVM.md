[toc]

# JVM

​	*JVM*是一种用于计算设备的规范，它是一个虚构出来的计算机，是通过在实际的计算机上仿真模拟各种计算机功能来实现的。

​	*Java*虚拟机主要分为五大模块：类装载器子系统、运行时数据区、执行引擎、本地方法接口和垃圾收集模块。

​	引入*Java*语言虚拟机后，*Java*语言在不同平台上运行时不需要重新编译。*Java*语言使用*Java*虚拟机屏蔽了与具体平台相关的信息，使得*Java*语言编译程序只需生成在*Java*虚拟机上运行的目标代码（字节码），就可以在多种平台上不加修改地运行。

# *Java*虚拟机内存

1. 程序计数器 虚拟机字节码指令的地址

2. 本地方法栈 为虚拟机使用到的 *Native* 方法服务，*Native* 方法是一种由非 *java* 语言实现的 *java* 方法，与 *java* 环境外交互，如可以用本地方法与操作系统交互

3. 虚拟机栈 描述的是 *Java* 方法执行的内存模型：每个方法在执行时都会创建一个栈帧用于存储局部变量表、操作栈、方法出口等信息。每一个方法从调用直至执行结束，就对应着一个栈帧从虚拟机栈中入栈到出栈的过程

4. 堆 所有的对象实例以及数组都要在堆上分配，此内存区域的唯一目的就是存放对象实例

5. 方法区 属于共享内存区域，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。

# 垃圾收集机制

* *GC*（*Garbage Collection* 垃圾收集），*GC*的对象是堆空间和永久区。

## *JVM* 如何确定垃圾对象

+ 引用计数

1. 给对象中添加一个引用计数器，每当有一个地方引用它时，计数器值加1；

2. 当引用失效时，计数器值就减1；

3. 任何时刻计数器为0的对象就是不可能再被使用的；

   **优点：引用计数收集器可以很快的执行，交织在程序运行中。对程序需要不被长时间打断的实时环境比较有利。**

   **缺点：无法解决循环引用，如父对象有一个对子对象的引用，子对象反过来引用父对象。这样，他们的引用计数永远不可能为0。**

+ 可达性分析

  *JVM* 采用的是可达性分析算法，通过 *GC* *Roots* 来判定对象是否存活，从 *GC* *Roots* 向下追溯、搜索，会产生 *Reference* *Chain*。当一个对象不能和任何一个 *GC* *Root* 产生关系时，就判定为垃圾。

  可作为 *GC* *Roots* 的对象包括下面几种：

> + 虚拟机栈（栈桢中的本地变量表）中的引用的对象
> + 方法区中的类静态属性引用的对象。
> + 方法区中的常量引用的对象。
> + 本地方法栈中 *JNI*（即一般说的 *Native* 方法）的引用的对象。

## GC算法

*GC*算法包含：标记清除，标记整理，复制算法，分代回收。 

### 标记——清除算法

​	标记-清除算法将垃圾回收分为两个阶段：标记阶段和清除阶段。在标记阶段，首先通过根节点，标记所有从根节点开始的可达对象。因此，未被标记的对象就是未被引用的垃圾对象。在清除阶段，会进行对象回收并取消标志位，另外，还会判断回收后的分块与前一个空闲分块是否连续，若连续，会合并这两个分块。回收对象就是把对象作为分块，连接到被称为 “空闲链表” 的单向链表，之后进行分配时只需要遍历这个空闲链表，就可以找到分块。

在分配时，程序会搜索空闲链表寻找空间大于等于新对象大小 *size* 的块 *block*。如果它找到的块等于 *size*，会直接返回这个分块；如果找到的块大于 *size*，会将块分割成大小为 *size* 与 (*block* - *size*) 的两部分，返回大小为 *size* 的分块，并把大小为 (*block* - *size*) 的块返回给空闲链表。

​	一个比较严重的问题就是容易产生内存碎片，碎片太多可能会导致后续过程中需要为大对象分配空间时无法找到足够的空间而提前触发新的一次垃圾收集动作

### 标记——整理算法


标记过程和标记整理算法一致，但回收阶段让所有存活的对象都向一端移动，然后直接清理掉端边界以外的内存。

优点：不会产生内存碎片；不足：需要移动大量对象，处理效率比较低。

 ### 复制算法

​	复制法将原有的内存空间分为两块，每次只使用其中一块，在垃圾回收时，将正在使用的内存中的存活对象复制到未使用的内存块中，之后，清除正在使用的内存块中的所有对象，交换两个内存的角色，完成垃圾回收。

​	这种算法虽然实现简单，运行高效且不容易产生内存碎片，但是却对内存空间的使用做出了高昂的代价，因为能够使用的内存缩减到原来的一半。

​	很显然，*Copying*算法的效率跟存活对象的数目多少有很大的关系，如果存活对象很多，那么 *Copying* 算法的效率将会大大降低。

### 分代收集算法

​	核心思想是根据对象存活的生命周期将内存划分为若干个不同的区域。一般情况下将堆区划分为老年代和新生代，在堆区之外还有一个代就是永久代。老年代的特点是每次垃圾收集时只有少量对象需要被回收，而新生代的特点是每次垃圾回收时都有大量的对象需要被回收，根据不同代的特点采取最适合的收集算法。

​	新生代使用复制算法，有 3 个分区：*Eden*、*To* *Survivor*、*From* *Survivor*，它们的默认占比是 8:1:1。新生成的对象主要生成在*eden*区，当*eden*区满了之后触发 *Minor* *GC*，将存活的对象复制到 *from* 区。当 *Eden* 区再次被用完，就再触发一次 *Minor* *GC*，将 *Eden* 区与 *From* 区还在被使用的对象复制到 *To* 区，移动一次，对象年龄加 1，对象年龄大于一定阈值会直接移动到老年代，再下一次 *Minor* *GC* 的时候，则是将 *Eden* 区与 *To* 区中的还在被使用的对象复制到 *From* 区。如果空间不够则会直接进入老年区。

​	*MinorGC*：在年轻代空间（*eden*区）不足的时候发生

​	*MajorGC*：老年代满时触发

​	*FullGC*：

> 老年代空间不足；
>
> 显式调用*System*.*gc*；
>
> *Concurrent Mode Failure*：执行 *CMS GC* 的过程中同时有对象要放入老年代，而此时老年代空间不足（可能是 *GC* 过程中浮动垃圾过多导致暂时性的空间不足），便会报 *Concurrent Mode Failure* 错误，并触发 *Full GC*。

​	*CMS GC* 时出现 *promotion failed* 和 *concurrent mode failure* 。*promotion failed* 是在进行 *Minor GC* 时，*survivor space* 放不下、对象只能放入旧生代，而此时旧生代也放不下造成的；*concurrent mode failure* 是在执行 *CMS GC* 的过程中同时有对象要放入旧生代，而此时旧生代空间不足造成的。

 ## 垃圾回收器

### 新生代垃圾回收器

+ *Serial* 收集器（复制算法)

  新生代单线程收集器，标记和清理都是单线程，优点是简单高效。是 *client* 级别默认的 *GC* 方式。 

+ *ParNew* 收集器(复制算法)　

  新生代收集器，可以认为是 *Serial* 收集器的多线程版本,在多核CPU环境下有着比 *Serial* 更好的表现。

+ *Parallel Scavenge* 收集器(复制算法)

  与 *ParNew* 类似，但是采用 *GC* 自适应调节策略以达到最高吞吐量

### 老年代垃圾回收器

+ *Serial Old* 收集器（标记——整理算法）

  老年代单线程收集器，*Serial* 收集器的老年代版本。

+ *Parallel Old*收集器(复制算法)

  *Parallel* *Scavenge*收集器的老年代版本，并行收集器，吞吐量优先。

### *CMS*垃圾回收器

1. *CMS*与*G1*都是并发回收，多线程分阶段回收，只有某阶段会 *stw*；
2. *CMS*只会回收老年代和永久代（1.8开始为元数据区，需要设置*CMSClassUnloadingEnabled*），不会收集年轻代； 
3. *CMS*是一种预处理垃圾回收器，它不能等到老年代内存用尽时回收，需要在内存用尽前，完成回收操作，否则会导致并发回收失败；所以*CMS*垃圾回收器开始执行回收操作，有一个触发阈值，默认是老年代或永久代达到92%；

### *G1*垃圾回收器

​	*G1*垃圾回收器把堆划分成一个个大小相同的*Region*。在*HotSpot*的实现中，整个堆被划分成2048左右个*Region*。每个*Region*的大小在1-32*MB*之间，具体多大取决于堆的大小。*G1*垃圾回收器的分代也是建立在这些*Region*的基础上的。对于*Region*来说，它会有一个分代的类型。即每一个*Region*，它要么是 *young* 的，要么是 *old* 的。还有一类十分特殊的 *Humongous*。所谓的 *Humongous* ，就是一个对象的大小超过了某一个阈值——*HotSpot*中是*Region*的1/2，那么它会被标记为*Humongous*。

​	每一个分配的*Region*，都可以分成两个部分，已分配的和未被分配的。它们之间的界限被称为 *top*。

​	*Region* 可以说是*G1*回收器一次回收的最小单元。即每一次回收都是回收 *N* 个 *Region*。这个 *N* 是多少，主要受到 *G1* 回收的效率和用户设置的软实时目标有关。每一次的回收，*G1* 会选择可能回收最多垃圾的*Region*进行回收。与此同时，*G1*回收器会维护一个空间 *Region* 的链表。每次回收之后的 *Region* 都会被加入到这个链表中。

​	每一次都只有一个 *Region* 处于被分配的状态中，被称为 *current region*。在多线程的情况下，这会带来并发的问题。解决办法是为每一个线程分配一个 *Buffer*，线程分配内存就在这个 *Buffer* 内分配。但是当线程耗尽了自己的 *Buffer* 之后，需要申请新的 *Buffer*。这个时候依然会带来并发的问题。*G1* 回收器采用的是 *CAS* 操作。

​	为线程分配*Buffer*的过程大概是：

1. 记录 *top* 值；

2. 准备分配；

3. 比较记录的 *top* 值和现在的 *top* 值，如果一样，则执行分配，并且更新 *top* 的值；否则，重复以上操作

# 常量池

## *Class*文件常量池

​    *class*文件常量池主要存放两大常量：字面量（文本字符串、被*final*修饰的变量）和符号引用（类和接口的全限定名、方法的名称和描述符、字段的名称和描述符）

## 运行时常量池

​	运行时常量池的作用是存储 *Java* *class* 文件常量池中的符号信息。运行时常量池中保存着一些 *class* 文件中描述的符号引用，同时在类加载的“解析阶段”还会将这些符号引用所翻译出来的直接引用(直接指向实例对象的指针)存储在运行时常量池中。

​	在运行时可以通过代码生成常量并将其放入运行时常量池中

## 字符串常量池

​	字符串常量池（*String* *Pool*）保存着所有字符串字面量（*literal* *strings*），这些字面量在编译时期就确定。不仅如此，还可以使用 *String* 的 *intern*() 方法在运行过程将字符串添加到 *String* *Pool* 中。

​	当一个字符串调用 intern() 方法时，如果 *String Pool* 中已经存在一个字符串和该字符串值相等（使用 *equals()* 方法进行确定），那么就会返回 *String Pool* 中字符串的引用；否则，就会在 *String Pool* 中添加一个新的字符串，并返回这个新字符串的引用。

# *Stop The World*

*Java* 中 *Stop-The-World* 机制简称 *STW*，是在执行垃圾收集算法时，*Java* 应用程序的其他所有线程都被挂起。*Java* 中一种全局暂停现象，全局停顿，所有 *Java* 代码停止，*native* 代码可以执行，但不能与 *JVM* 交互

*STW* 总会发生，不管是新生代还是老年代，比如 *CMS* 在初始标记和重复标记阶段会停顿，*G1* 在初始标记阶段也会停顿，所以并不是选择了一款停顿时间低的垃圾收集器就可以避免 *STW* 的，我们只能尽量去减少 *STW* 的时间。

为什么有 *STW*？因为在定位堆中的对象时 *JVM* 会记录下对所有对象的引用，如果在定位对象过程中，有新的对象被分配或者刚记录下的对象突然变得无法访问，就会导致一些问题，比如部分对象无法被回收，更严重的是如果 *GC* 期间分配的一个 *GC Root* 对象引用了准备被回收的对象，那么该对象就会被错误地回收。

# *Java*跨平台运行的原理

1. *java* 源文件要先编译成与操作系统无关的 .*class* 字节码文件，然后字节码文件再通过 *Java* 虚拟机解释成机器码运行。

2. *class* 字节码文件面向虚拟机，不面向任何具体操作系统。

3. 不同平台的虚拟机是不同的，但它们给 *JDK* 提供了相同的接口。

4. *Java* 的跨平台依赖于不同系统的 *Java* 虚拟机。

# *Java*类加载过程

类加载的步骤为，加载 -> 验证 -> 准备 -> 解析 -> 初始化。

1. 加载：

   获取类的二进制字节流

   将字节流代表的静态存储结构转化为方法区运行时数据结构

   在堆中生成 *class* 字节码对象

2. 验证：

   连接过程的第一步，确保 *class* 文件的字节流中的信息符合当前 *JVM* 的要求，不会危害 *JVM* 的安全

3. 准备：

   为类的静态变量分配内存并将其初始化为默认值

4. 解析：

   *JVM* 将常量池内符号引用替换成直接引用的过程（我们编写的本地代码在进行编译成.*class*文件后，方法之间调用的关系通过字节码的形式存在，这就是符号引用；而在 *JVM* 将类加载到内存中后，方法之间要互相调用就要通过对象的地址，这就是一种直接引用）

5. 初始化：

   执行类构造器的初始化的过程

# 新生对象分配内存

​	对象所需的内存大小在类加载完成后便可完全确定，为对象分配内存空间的任务相当于将一块确定大小的内存从*java*堆中划出来。分配内存有两种方法：指针碰撞和空闲列表。

> + 指针碰撞：假设 *java* 堆中内存是绝对规整的，所有用过的内存都放到一边，空闲的内存放到另一边，中间放着一个指针作为分界点的指示器，分配内存时将指针向空闲空间挪一段与对象大小相等的距离。
>
> + 空闲列表：如果 *java* 堆内存并不是规整的，已用的内存和空闲的内存交错。虚拟机维护一个列表，记录上哪些内存是可用的，在分配时从列表中找到一块足够大的空间划分给对象实例，并更新列表上的记录。

# 对象访问定位

​	*Java*程序通过虚拟机栈中的*reference*数据来操作堆上的具体对象，这个引用去定位具体对象有两种方式：句柄访问和直接指针访问。

+ 句柄访问： *Java*堆中划分出一块内存来作为句柄池，*reference*中存储的就是对象的句柄地址，而句柄中包含了对象实例数据与类型数据各自的具体地址信息。实际上是采用了句柄池这样一个中间介质进行了两次指针定位，有效的避免了对象的移动或改变直接导致*reference*本身发生改变。使用句柄访问最大的好处就是*reference*中存储的是稳定的句柄地址，在对象回收过程中或者其它对象需要移动的时，只会改变句柄中的实例数据的指针，而*reference*本身不需要做任何修改。

  ![通过句柄访问对象](/picture/通过句柄访问对象.png)

+ 直接指针访问：如果使用直接指针访问，那么 *Java* 堆对象的布局必须考虑如何放置访问类型的数据的相关信息，而*reference*中存储的直接就是对象地址，而不再是句柄地址信息，相当于在*reference*与对象地址信息直接少了句柄池这样一个中间地址，*reference*中直接存储的就是对象地址。这种定位方式也就导致了在对象被移动时，*reference*本身必须发生改变。但是我们都知道，使用句柄访问方式时，相当于进行了两次指针定位，而直接指针访问方式恰好节省了这一次指针定位的时间开销，由于对象的访问在 *Java* 中非常的频繁，时间开销的减少也是一种可观的执行成本。

  ![通过直接指针访问对象](/picture/通过直接指针访问对象.png)

# 软引用、弱引用、虚引用

​	软引用是用来描述一些有用但并不是必需的对象，用*SoftReference*类来表示。对于软引用关联着的对象，只有在内存不足的时候*JVM*才会回收该对象。

​	弱引用也是用来描述非必需对象的，当 *JVM* 进行垃圾回收时，无论内存是否充足，都会回收被弱引用关联的对象。用*WeakReference*类来表示。

​	虚引用和前面的软引用、弱引用不同，它并不影响对象的生命周期，也无法通过虚引用得到一个对象。用*PhantomReference*类表示。为一个对象设置虚引用的唯一目的是能在这个对象被回收时收到一个系统通知。

# *JIT*

​	*Just* *In* *Time* *Compiler* 的简称，即时编译器。为了提高热点代码的执行效率，在运行时，虚拟机将会把这些代码编译成与本地平台相关的机器码，并进行各种层次的优化，完成这个任务的编译器就是 *JIT*。

# 双亲委派模型

​	除了顶层的启动类加载器，其他的类加载器在加载之前，都会委派给它的父加载器进行加载，一层层向上传递，直到所有父类加载器都无法加载，自己才会加载该类。

## 作用

1. 更好地解决了各个类加载器协作时基础类的一致性问题，避免类的重复加载；
2. 防止核心 *API* 库被随意篡改。如果有人想替换系统级别的类，比如 *String.java*，篡改它的实现，在这种机制下这些系统的类已经被加载过了，所以其他类加载器并没有机会再去加载，从一定程度上防止了危险代码的植入。

