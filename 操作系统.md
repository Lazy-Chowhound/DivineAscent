[toc]

# 死锁

## 死锁的必要条件

1. 互斥条件
   在一段时间内某资源仅为一个进程所占有。

2. 不可剥夺
   进程所获得的资源在未使用完毕之前，不能被其他进程强行夺走，只能由进程自己主动释放。
3. 请求与保持
   进程在请求其他资源的时候，继续占有已经获得的资源。
4. 循环等待

## 死锁避免

​	银行家算法

## 死锁预防

1. 破坏互斥条件

   例如假脱机打印机技术允许若干个进程同时输出，唯一真正请求物理打印机的进程是打印机守护进程。

2. 破坏请求并保持条件

   一种实现方式是规定所有进程在开始执行前请求所需要的全部资源。

3. 破坏不可抢占条件

4. 破坏环路等待

   给资源统一编号，进程只能按编号顺序来请求资源。

# 系统调用

在 *OS* 的核心中一组用于实现各种系统功能的子程序(过程)，并将它们提供给应用程序调用

# 中断

中断是指 *CPU* 对系统发生某事件时的这样一种响应: *CPU* 暂停正在执行的程序，在保留现场后自动地转去执行中断处理程序；执行完后，再返回到原程序的断点处继续执行。

##  外中断

是指由于外部设备事件所引起的中断，如通常的磁盘中断、打印机中断等；

## 内中断

是指由于 *CPU* 内部事件所引起的中断，如程序出错(非法指令、数组越界)。内中断 (*trap*) 也被译为“捕获”或“陷入”。

# 陷入

陷入，又叫访管指令，用于实现在用户态下运行的进程调用操作系统内核程序，即当运行的用户进程或系统实用进程欲请求操作系统内核为其服务时，可以安排执行一条陷入指令引起一次特殊异常，从用户态转变为内核态。

# 进程与线程

进程是资源分配的基本单位。

进程控制块(*Process Control Block, PCB*)描述进程的基本信息和运行状态，所谓的创建进程和撤销进程，都是指对 *PCB* 的操作。

---

线程是独立调度的基本单位。

一个进程中可以有多个线程，它们共享进程资源。

## 区别

1. 拥有资源

   进程是资源分配的基本单位，但是线程不拥有资源，线程可以访问隶属进程的资源。

2. 调度

   线程是独立调度的基本单位，在同一进程中，线程的切换不会引起进程切换；从一个进程中的线程切换到另一个进程中的线程时，会引起进程切换。

3. 系统开销

   由于创建或撤销**进程**时，系统都要为之分配或回收资源，如内存空间、*I/O* 设备等，所付出的开销远大于创建或撤销**线程**时的开销。类似地，在进行进程切换时，涉及当前执行进程 *CPU* 环境的保存及新调度进程 *CPU* 环境的设置，而线程切换时只需保存和设置少量寄存器内容，开销很小。

4. 通信方面

   线程间可以通过直接读写同一进程中的数据进行通信，但是进程通信需要借助 *IPC*。

 # 线程间的通信方式

1. (命名)管道：通常用于不相关的进程间的通信(任意两个进程间的通信)，它是一种特殊的文件，在文件系统中以文件名的形式存在，

2. 无名管道：用于父子进程间的通信

3. 共享内存：

5. 信号量：是一个计数器，用于为多个进程提供对共享数据对象的访问。

6. 消息队列

7. 套接字：可用于不同机器间通信

# 虚拟内存

虚拟内存的目的是为了让物理内存扩充成更大的逻辑内存，从而让程序获得更多的可用内存。

为了更好的管理内存，操作系统将内存抽象成地址空间。每个程序拥有自己的地址空间，这个地址空间被分割成多个块，每一块称为一页。这些页被映射到物理内存，但不需要映射到连续的物理内存，也不需要所有页都必须在物理内存中。当程序引用到不在物理内存中的页时，由硬件执行必要的映射，将缺失的部分装入物理内存并重新执行失败的指令。

从上面的描述中可以看出，虚拟内存允许程序不用将地址空间中的每一页都映射到物理内存，也就是说一个程序不需要全部调入内存就可以运行，这使得有限的内存运行大程序成为可能。

 # 分段和分页

## 目的

​	首先分页和分段都是为了更好的管理内存，是内存的管理方式。

​	假如没有分段和分页机制相当于直接操作内存，那么程序员在写代码的时候要自己考虑并写死用哪些物理地址，而且程序的运行一定需要连续的地址来一次装入程序。

​	上面的情况将引来三个问题：

​	程序之间很容易相互影响，因为是直接操作内存的物理地址，那么程序*B*可能会出现修改覆盖程序*A*地址的情况，没有有效隔离进程的地址空间。

​	程序的地址难以把握，因为物理地址是写死的，假如程序写死操作的内存地址范围是 *0x00000010 0x00000020*，但是装入程序的时候放在了 *0x00000030 0x00000040* 上，那么程序操作的压根不是程序占有的内存地址。

​	换入换出的时候，因为地址必须连续，导致无法利用离散的小内存块，这种问题使内存利用率低。

## 分页存储管理

​	用户程序的地址空间被划分成若干固定大小的区域，称为“页”，相应地，内存空间分成若干个物理块，页和块的大小相等。可将用户程序的任一页放在内存的任一块中，实现了离散分配。为了能在内存中找到每个页面对应的物理块，系统为每个进程建立一张页表，用于记录进程逻辑页面与内存物理页面之间的对应关系。页表的作用是实现从页号到物理块号的地址映射，地址空间有多少页，该页表里就登记多少行，且按逻辑页的顺序排列。

 ## 分段存储管理

​	作业的地址空间被划分为若干个段，每个段定义了一组逻辑信息。每个段都有自己的名字，每个段都是从0开始编址的一段连续的地址空间。段的长度由相应的逻辑信息组的长度决定，因而各段长度不等。整个作业的地址空间由于是分成多个段，其逻辑地址由段号(段名)和段内地址所组成

 ## 分页和分段的区别

### 相同点

​	两者都采用离散分配方式，且都地址映射机构来实现地址的转换

### 不同点

1. 页的大小固定且有系统决定，在采用分页存储管理方式中直接由硬件实现。而段的大小不固定，决定于用户所编写的程序。
3. 分页的地址空间是一维的，分段系统中是二维的。
3. 分页完全是系统的行为，分段则需要人为显式划分。
4. 分页主要用于实现虚拟内存，从而获得更大的地址空间；分段主要是为了使程序和数据可以被划分为逻辑上独立的地址空间并且有助于共享和保护。

# 静态链接和动态连接

[静态连接和动态链接](https://github.com/CyC2018/CS-Notes/blob/master/notes/%E8%AE%A1%E7%AE%97%E6%9C%BA%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F%20-%20%E9%93%BE%E6%8E%A5.md)

