[toc]

*MQ*（*Message* *Queue*）消息队列，是 "先进先出" 的一种数据结构。

# *MQ* 的作用

一般用来解决应用解耦，异步处理，流量削峰等问题，实现高性能，高可用，可伸缩和最终一致性架构

1. 应用解耦：

   当 *A* 系统生产关键数据，发送数据给多个其他系统消费，此时 *A* 系统和其他系统产生了严重的耦合，如果将 *A* 系统产生的数据放到 *MQ* 当中，其他系统去 *MQ* 获取消费数据，此时各系统独立运行只与 *MQ* 交互，添加新系统消费 *A* 系统的数据也不需要去修改 *A* 系统的代码，达到了解耦的效果。

2. 异步处理：

   互联网类企业对用户的直接操作，一般要求每个请求在 200*ms* 以内完成。对于一个系统调用多个系统，不使用 *MQ* 的情况下，它执行完返回的耗时是调用完所有系统所需时间的总和；使用 *MQ* 进行优化后，执行的耗时则是执行主系统的耗时加上发送数据到消息队列的耗时，大幅度提升系统性能和用户体验。

3. 流量削峰：

   *MySql* 每秒最高并发请求在 2000 左右，用户访问量高峰期的时候涌入的大量请求，会将 *MySql* 打死，然后系统就挂掉，但过了高峰期，请求量可能远低于 2000，这种情况去增加服务器就不值得，如果使用 *MQ* 的情况，将用户的请求全部放到 *MQ* 中，让系统去消费用户的请求，不要超过系统所能承受的最大请求数量，保证系统不会再高峰期挂掉，高峰期过后系统还是按照最大请求数量处理完请求。

# 如何保证消息不被重复消费?

​	消息被重复消费，就是消费方多次接受到了同一条消息。根本原因就是，第一次消费完之后，消费方给 *MQ* 确认已消费的反馈，*MQ* 没有成功接受，比如网络原因、*MQ* 重启等。

​	所以 *MQ* 是无法保证消息不被重复消费的，只能业务系统层面考虑。

​	保证消息消费的幂等性可以考虑下面的方式：

​	发送消息时给消息带上全局唯一 *id*，消费者拿到消息时，先去 *redis/db* 中查看该消息是否存在，不存在则正常消费，消费完写入 *redis/db*；若存在，则说明该消息消费过，丢弃该消息。

# 如何保证消息不丢失？

​	生产者丢失消息：如网络传输中丢失消息、*MQ* 发生异常未成功接收消息等情况。解决办法：主流的 *MQ* 都有确认或事务机制，可以保证生产者将消息送达到 *MQ*。如*RabbitMQ* 就有事务模式和 *confirm* 模式。

​	*MQ*丢失消息：*MQ* 成功接收消息内部处理出错、宕机等情况。解决办法：开启 *MQ*的持久化配置。

​	消费者丢失消息：采用消息自动确认模式，消费者取到消息未处理挂掉了。解决办法：改为手动确认模式，消费者成功消费消息再确认。

 # 消息确认机制

## 自动确认

*mq* 发送消息给消费者后立即就把消息删除

## 手动确认

*mq* 发送消息后消息还在队列中，收到消费者发送的 *ack* 后再删除

如果服务器端一直没有收到消费者的 *ack* 信号，并且消费此消息的消费者已经断开连接，则服务器端会安排该消息重新进入队列，等待投递给下一个消费者（也可能还是原来的那个消费者）。

*RabbitMQ* 不会为未 *ack* 的消息设置超时时间，它判断此消息是否需要重新投递给消费者的唯一依据是消费该消息的消费者连接是否已经断开。这么设计的原因是*RabbitMQ*允许消费者消费一条消息的时间可以很久。
