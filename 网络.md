 [TOC]

# *OSI*七层模型和*TCP/IP*五层模型

## *OSI*七层模型

​	物理层、数据链路层、网络层、传输层、会话层、表示层、应用层

## *TCP/IP五层模型*

​	物理层、数据链路层、网络层、传输层、应用层

# *TCP*和*UDP*

​	*TCP*面向连接，可靠，基于字节流，而*UDP*不面向连接，不可靠，基于数据报。

## 区别

1. *tcp*是基于连接的，可靠性高；*udp*是基于无连接的，可靠性较低；

2. *tcp*报头20字节；*udp*首部开销只有8个字节，*tcp*报头比*udp*复杂，故实际包含的用户数据较少。*tcp*开销大，*udp*开销较小；

3. *TCP*保证数据顺序，*UDP*不保证 ;

   对数据传输的完整性、正确性有较高要求则使用*TCP*，如果对实时性有要求则使用*UDP*（如视频）

## 补充：TCP如何保持连接

​	当网络两端建立了*TCP*连接之后，闲置（双方没有任何数据流发送往来）了*tcp*_*keepalive*_*time*后，服务器就会尝试向客户端发送侦测包，来判断*TCP*连接状况(有可能客户端崩溃、强制关闭了应用、主机不可达等等)。如果没有收到对方的回答(*ack*包)，则会在 *tcp*_*keepalive*_*intvl*后再次尝试发送侦测包，直到收到对方的*ack*,如果一直没有收到对方的*ack*,一共会尝试 *tcp*_*keepalive*_*probes*次，每次的间隔时间在这里分别是15*s*, 30*s*, 45*s*, 60*s*, 75*s*。如果尝试*tcp*_*keepalive*_*probes*,依然没有收到对方的*ack*包，则会丢弃该*TCP*连接。

 # 三次握手

> 1. 第一次握手：客户端给服务器发送一个 *SYN* 报文。
>
> 2. 第二次握手：服务器收到 *SYN* 报文之后，会应答一个 *SYN*+*ACK* 报文。
>
> 3. 第三次握手：客户端收到 *SYN*+*ACK* 报文之后，会回应一个 *ACK* 报文。
>
> 4. 服务器收到 *ACK* 报文之后，三次握手建立完成。

​	为了保证服务端能收接受到客户端的信息并能做出正确的应答而进行前两次(第一次和第二次)握手，为了保证客户端能够接收到服务端的信息并能做出正确的应答而进行后两次(第二次和第三次)握手

​	假设只有两次握手，当*A*想要建立连接时发送一个*SYN*，然后等待*ACK*，结果这个*SYN*因为网络问题没有及时到达*B*，所以*A*在一段时间内没收到*ACK*后，在发送一个*SYN*，*B*也成功收到，然后*A*也收到*ACK*，这时*A*发送的第一个*SYN*终于到了*B*，对于*B*来说这是一个新连接请求，然后*B*又为这个连接申请资源，返回*ACK*，然而这个*SYN*是个无效的请求，*A*收到这个*SYN*的*ACK*后也并不会理会它，而*B*却不知道，*B*会一直为这个连接维持着资源，造成资源的浪费

​	那三次握手为什么可以？两次握手的问题在于服务器端不知道一个*SYN*是否是无效的，而三次握手机制因为客户端会给服务器回复第二次握手，也意味着服务器会等待客户端的第三次握手，如果第三次握手迟迟不来，服务器便会认为这个*SYN*是无效的，释放相关资源。但这时有个问题就是客户端完成第二次握手便认为连接已建立，而第三次握手可能在传输中丢失，服务端会认为连接是无效的，这时如果*Client*端向*Server*写数据，*Server*端将以*RST*包响应，方能感知到*Server*的错误。

# 四次挥手

1. 第一次挥手：客户端发送一个 *FIN* 报文，报文中会指定一个序列号。此时客户端处于*FIN*_*WAIT*1状态。

2. 第二次握手：服务端收到 *FIN* 之后，会发送 *ACK* 报文，且把客户端的序列号值 + 1 作为 *ACK* 报文的序列号值，表明已经收到客户端的报文了，此时服务端处于 *CLOSE*_*WAIT*状态。

3. 第三次挥手：如果服务端也想断开连接了，和客户端的第一次挥手一样，发给 *FIN* 报文，且指定一个序列号。此时服务端处于 *LAST*_*ACK* 的状态。

4. 第四次挥手：客户端收到 *FIN* 之后，一样发送一个 *ACK* 报文作为应答，且把服务端的序列号值 + 1 作为自己 *ACK* 报文的序列号值，此时客户端处于 *TIME*_*WAIT* 状态。需要过一阵子以确保服务端收到自己的 *ACK* 报文之后才会进入 *CLOSED* 状态

5. 服务端收到 *ACK* 报文之后，就处于关闭连接了，处于 *CLOSED* 状态。

 ## *TIME*_*WAIT*

​	*TIME*_*WAIT*这个状态了，这个是面试的高频考点，就是要理解，为什么客户端发送 *ACK* 之后不直接关闭，而是要等一阵子才关闭。这其中的原因就是，要确保服务器是否已经收到了我们的 *ACK* 报文，如果没有收到的话，服务器会重新发 *FIN* 报文给客户端，客户端再次收到 *ACK* 报文之后，就知道之前的 *ACK* 报文丢失了，然后再次发送 *ACK* 报文。

# 为什么建立连接是三次，而关闭连接却是四次？

​	这是因为建立连接时，服务端收到 *SYN* 报文的建连请求后，它可以把 *ACK* 和 *SYN*（*ACK* 起应答作用，而 *SYN* 起同步作用）放在一个报文里来发送。但关闭连接时，当收到对方的 *FIN* 报文通知时，它仅仅表示对方没有数据发送给你了，但是你还可以给对方发送数据，或者也可能你还有一些数据在传给对方的途中，所以你不能立马关闭连接,也即你可能还需要把在传输途中的数据给对方之后，又或者你还有一些数据需要传输给对方后（再关闭连接）再发送*FIN* 报文给对方来表示你同意现在可以关闭连接了，所以它这里的 *ACK* 报文和 *FIN* 报文多数情况下都是分开发送的。

# 拥塞控制



# *Socket*和*WebSocket*

## *http*和*websocket*的区别

​	*http*协议是短链接，因为请求之后，都会关闭连接，下次请求需要重新打开链接。

​	*websocket*协议是一种长连接，只需要通过一次请求来初始化连接，然后所有请求和响应都是通过*TCP*链接进行通信。

## *websocket*和*socket*的区别？

​	*socket*是应用层与*TCP*/*IP*协议通信的中间软件抽象层，它是一组接口。

​	而*websocket*协议是一个完整的应用层协议，拥有一套完整的*API*，允许服务器向客户端传递信息，实现浏览器和客户端双工通信。。

# *Session*和*Cookies*

## *Cookie*

​    *response*.*add*(*cookie*)

​    *Cookie*实际上是一小段的文本信息。客户端请求服务器，如果服务器需要记录该用户状态，就使用*response*向客户端浏览器颁发一个*Cookie*。客户端浏览器会把*Cookie*保存起来。当浏览器再请求该网站时，浏览器把请求的网址连同该*Cookie*一同提交给服务器。服务器检查该*Cookie*，以此来辨认用户状态。服务器还可以根据需要修改*Cookie*的内容。

　　如果*maxAge*为0，则表示删除该*Cookie*。*Cookie*机制没有提供删除*Cookie*的方法，因此通过设置该*Cookie*即时失效实现删除*Cookie*的效果。失效的*Cookie*会被浏览器从*Cookie*文件或者内存中删除，

## *Session*

​    *request*.*getSession*()

​	因此同一机器的两个浏览器窗口访问服务器时，会生成两个不同的*Session*。但是由浏览器窗口内的链接、脚本等打开的新窗口（也就是说不是双击桌面浏览器图标等打开的窗口）除外。这类子窗口会共享父窗口的*Cookie*，因此会共享一个*Session*。

​	注意：新开的浏览器窗口会生成新的*Session*，但子窗口除外。子窗口会共用父窗口的*Session*。例如，在链接上右击，在弹出的快捷菜单中选择“在新窗口中打开”时，子窗口便可以访问父窗口的*Session*。

　*URL*地址重写是对客户端不支持*Cookie*的解决方案。*URL*地址重写的原理是将该用户*Session*的*id*信息重写到*URL*地址中。服务器能够解析重写后的*URL*获取*Session*的*id*。这样即使客户端不支持*Cookie*，也可以使用*Session*来记录用户状态。

​	*Session* 可以存储在服务器上的文件、数据库或者内存中。也可以将 *Session* 存储在 *Redis* 这种内存型数据库中，效率会更高。

使用 *Session* 维护用户登录状态的过程如下：

>  用户进行登录时，用户提交包含用户名和密码的表单，放入 *HTTP* 请求报文中；
>
> 服务器验证该用户名和密码，如果正确则把用户信息存储到 *Redis* 中，它在 *Redis* 中的 *Key* 称为 *Session* *ID*；
>
> 服务器返回的响应报文的 *Set*-*Cookie* 首部字段包含了这个 *Session* *ID*，客户端收到响应报文之后将该 *Cookie* 值存入浏览器中；
>
> 客户端之后对同一个服务器进行请求时会包含该 *Cookie* 值，服务器收到之后提取出 *Session* *ID*，从 *Redis* 中取出用户信息，继续之前的业务操作。

除了可以将用户信息通过 *Cookie* 存储在用户浏览器中，也可以利用 *Session* 存储在服务器端，存储在服务器端的信息更加安全。



# *HTTP*状态码

100 *Continue* 客户端事先发送一个只带头域的请求。100 (*Continue*) 状态代码的使用，允许客户端在发*request*消息*body*之前先用*request* *header*试探一下*server*，看*server*要不要接收*request* *body*，再决定要不要发*request* *body*。

---

200 *OK* 请求成功。

201 *Created* 已创建 成功请求并创建了新的资源

202 *Accepted* 已接受 已经接受请求，但未处理完成

---

300 与重定向有关

301 *Moved Permanently* 资源被永久移动到其他*URI*，返回新的*URI*并重定向到新*URI*

302 *Moved Temporarily* 资源被暂时移动到其他，应使用原来的*URI*

---

400 *Bad* *Request*  客户端请求的语法错误，服务器无法理解

401 *Unauthorized* 请求要求用户的身份认证

403 *Forbidden*   服务器理解请求客户端的请求，但是拒绝执行此请求

404 *Not* *Found*   服务器无法根据客户端的请求找到资源（网页）。

405 *Method* *Not* *Allowed*   客户端请求中的方法被禁止

---

500 *Internal* *Server* *Error* 服务器内部错误，无法完成请求

501 *Not* *Implemented*  服务器不支持请求的功能，无法完成请求

502 *Bad* *Gateway* 网关或者代理工作的服务器尝试执行请求时，从远程服务器接收到了一个无效的响应

503 *Service* *Unavailable* 由于超载或系统维护，服务器暂时的无法处理客户端的请求。

 # *HTTP*请求报文和响应报文字段

## 请求报文

​    请求行：请求方法 请求的*URL* 协议及其版本

​    请求头：请求的主机名和端口*host*、请求来源*origin*、请求的原始*URLreferer*、*user*-*agent*、*Accept*-*Encoding*、*Accept*-*Language*

​    请求体：相关数据

 ## 响应报文

​    响应行：协议及其版本 状态码

​    响应头：*Access*-*Control*-*Allow*-*Origin* 、*Access*-*Control*-*Allow*-*Methods*、*Content*-*Type*、*Content*-*Length*

​    实体：返回的数据

# *HTTP*1.0和*HTTP*2.0的区别

## 多路复用

​	*HTTP*2.0使用了多路复用的技术，做到同一个连接并发处理多个请求，

## *header*压缩

​	在*HTTP*1.1中，*HTTP*请求和响应都是由状态行、请求/响应头部、消息主体三部分组成。一般而言，消息主体都会经过压缩，但状态行和头部却没有经过任何压缩，直接以纯文本传输。随着请求数越来越多，导致消耗在头部的流量越来越多，尤其是每次都要传输*User-Agent*、*Cookie*这类不会频繁变动的内容，完全是一种浪费。

​	*HTTP*1.1不支持*header*数据的压缩，*HTTP*2.0使用*HPACK*算法对*header*的数据进行压缩，这样数据体积小了，在网络上传输就会更快

## 服务器推送

​	网页使用了许多资源：*Html*、*Css*、*js*等等。在*HTTP*1.1中这些资源每一个都必须明确地请求。这是一个很慢的过程，因为服务器必须等待浏览器做每一个请求，网络经常是空闲的和未充分使用的。

​	*HTTP*2.0引入了*server push*，它允许服务端推送资源给浏览器，在浏览器明确地请求之前，免得客户端再次创建连接发送请求到服务器端获取。

# *HTTP*2一次发送多个*http*请求时如何区分回应的是哪个请求

​	通过*stream* *identifier*流标志符

 

