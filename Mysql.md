# 最左原则

​	*MySql*索引底层采用*B*+树的数据结构，仅在叶子节点存储数据，并且从左到右串联起来便于范围查询。这样的结构导致复合索引的查询符合“最左原则”，也就是当建立（*a*,*b*,*c*）复合索引时，查询条件中必须有*a*才能走索引，*a*,*ab*,*ac*,*abc*均;但是*b*,*bc*,*c*都不能走索引。

​	索引*index*1:(*a*,*b*,*c*)，只会走*a*、*a*,*b*、*a*,*b*,*c* 三种类型的查询，其实这里说的有一点问题，*a*,*c*也走，但是只走*a*字段索引，不会走*c*字段。

# 索引失效

   1.没有遵循最左前缀原则；

  2.在*where*条件判断中使用>符号这种范围查询；

  3.在*where*条件判断中使用<>、!=；

  4.使用*is* *not* *null* 或者*is* *null*也会导致索引失效；

  5.模糊查询时查询条件最前边有通配符，即*like*查询是以%开头；

  6.使用了*or*的情况下，只有所有条件有索引才能使用索引 ；

  7.对于字符字段没有用单引号，导致索引失效会全表扫描；

# 全文索引

用于查找文本中的关键词，而不是直接比较是否相等。

查找条件使用 *MATCH AGAINST*，而不是普通的 *WHERE*。

全文索引使用倒排索引实现，它记录着关键词到其所在文档的映射。

# 索引优化

## 1. 独立的列

在进行查询时，索引列不能是表达式的一部分，也不能是函数的参数，否则无法使用索引。

例如下面的查询不能使用 *actor_id* 列的索引：

```sql
SELECT actor_id FROM sakila.actor WHERE actor_id + 1 = 5;
```

## 2. 多列索引

在需要使用多个列作为条件进行查询时，使用多列索引比使用多个单列索引性能更好。例如下面的语句中，最好把 *actor_id* 和 *film_id* 设置为多列索引。

```sql
SELECT film_id, actor_ id FROM sakila.film_actor
WHERE actor_id = 1 AND film_id = 1;
```

## 3. 索引列的顺序

让选择性最强的索引列放在前面。

索引的选择性是指：不重复的索引值和记录总数的比值。最大值为 1，此时每个记录都有唯一的索引与其对应。选择性越高，每个记录的区分度越高，查询效率也越高。

例如下面显示的结果中 *customer_id* 的选择性比 *staff_id* 更高，因此最好把 *customer_id* 列放在多列索引的前面。

```sql
SELECT COUNT(DISTINCT staff_id)/COUNT(*) AS staff_id_selectivity,
COUNT(DISTINCT customer_id)/COUNT(*) AS customer_id_selectivity,
COUNT(*)
FROM payment;

staff_id_selectivity: 0.0001
customer_id_selectivity: 0.0373
COUNT(*): 16049
```

## 4. 前缀索引

对于 *BLOB*、*TEXT* 和 *VARCHAR* 类型的列，必须使用前缀索引，只索引开始的部分字符。

好处：节约索引空间，提高索引效率。

## [5. 覆盖索引](#聚簇索引、回表查询与覆盖索引)

索引包含所有需要查询的字段的值。

具有以下优点：

- 索引通常远小于数据行的大小，只读取索引能大大减少数据访问量。
- 一些存储引擎（例如 *MyISAM*）在内存中只缓存索引，而数据依赖于操作系统来缓存。因此，只访问索引可以不使用系统调用（通常比较费时）。
- 对于 *InnoDB* 引擎，若辅助索引能够覆盖查询，则无需访问主索引。



# 范式

## 第一范式

每个字段都是单一属性的 不可再分

## 第二范式

每个非主属性都完全函数依赖于主属性

设*X*,*Y*是关系*R*的两个属性集合，当任何时刻*R*中的任意两个元组中的*X*属性值相同时，则它们的*Y*属性值也相同，则称*X*函数决定*Y*，或*Y*函数依赖于*X*，*X*→*Y*。

设*X*,*Y*是关系*R*的两个属性集合，*X*’是*X*的真子集，存在*X*→*Y*，但对每一个*X*’都有*X*’!→*Y*，则称*Y*完全函数依赖于*X*。

## 第三范式

非主属性必须直接依赖于主属性，而不能传递依赖于主属性。即不能存在：主属性*A*→非主属性*B*，非主属性*B*→非主属性*C*。 

 # 事务隔离级别

| 隔离级别 | 脏读 | 不可重复读 | 幻读 |
| -------- | ---- | ---------- | ---- |
| 未提交读 | 是   | 是         | 是   |
| 已提交读 | 不是 | 是         | 是   |
| 可重复读 | 不是 | 不是       | 是   |
| 可串行化 | 不是 | 不是       | 不是 |

## 脏读

一个事务对数据进行更新操作，但还完成，此时另一事务读取该数据，如果此时第一个事务由于操作失败进行了回滚，那么此时另外事务读取的数据就是脏数据。

## 不可重复读

例如事务*A*在读取某一数据，而事务*B*立马修改了这个数据并且提交事务给数据库，事务*A*再次读取该数据就得到了不同的结果，发送了不可重复读。

## 幻读

事务在插入已经检查过不存在的记录时，惊奇的发现这些数据已经存在了，之前的检测获取到的数据如同鬼影一般。例如：事务1查询是否存在*id*为1的用户，如果不存在则插入一条。在事务1查询结束之后，事务2向表中插入一条*id*为1的用户记录。因为之前事务1没有查询到*id*为1的用户所以此时要插入，但是由于事务2已经插入了*id*为1的用户，所以事务1插入会报错。

# 数据库优化

1. *sql*语句中不使用子查询，比如*delete* *from* *user* *where* *uid* *not* *in*( *select* *id* *from* *order*)，因为使用子查询数据库要在内存中建立临时表，消耗资源，如果两个表有关联并且经常被一块调用，最好是在一张表中建立另一张表的外键用*join*语句查询，比如：*delete* *from* *user* *left* *join* *order* *on* *user*.*id* = *order*.*uid*;

2. *sql*语句中最好不要出现"*"来代替已知字段，即使是要查询所有字段也要写出每一个字段，因为用*代替字段数据库要先查询出表中有哪些字段再进行*sql*语句的查询，无形中又多了一次无意义的查询工作；

3. 合理建立索引

   索引可以非常大程度加快数据库检索速度，尤其是在*where*和*join*中出现的列或者用*order* *by*排序的时候速度更是快很多（需要判断或者比较或者排序的时候）；

   但是建立索引并不是越多越好，过多索引会造成冗余，因为每一次*delete*、*update*、*add*都会刷新一次索引，过多索引造成其他操作消耗过多资源，过小的表也没必要建立索引。

# *MyISAM*与*InnoDB*的区别

## *InnoDB*

默认事务型引擎，被广泛使用的存储引擎

数据存储在共享表空间，即多个表和索引都存储在一个表空间中，可通过配置文件修改

主键查询的性能高于其他类型的存储引擎

内部做了很多优化，如：从磁盘读取数据时会自动构建*hash*索引，插入数据时自动构建插入缓冲区

通过一些机制和工具支持真正的热备份

支持崩溃后的安全恢复

支持行级锁

支持外键

## *MyISAM*

拥有全文索引、压缩、空间函数

不支持事务和行级锁、不支持崩溃后的安全恢复

表存储在两个文件：*MYD* 和 *MYI*

设计简单，某些场景下性能很好，例如获取整个表有多少条数据，性能很高

## 总结

*InnoDB* 存储引擎提供了具有提交、回滚、崩溃恢复能力的事务安全，与 *MyISAM* 比 *InnoDB* 写的效率差一些，并且会占用更多的磁盘空间以保留数据和索引

*MyISAM* 不支持事务、也不支持外键，优势是访问的速度快。对事务的完整性没有要求、以 *SELECT* 和 *INSERT* 为主的应用可以使用这个存储引擎

# 什么是触发器，*MySQL*都有哪些触发器

触发器是一段代码，当触发某个事件时，自动执行这些代码

*MySQL* 数据库中有六种触发器：

*Before* *Insert*、*After* *Insert*

*Before* *Update*、*After* *Update*

*Before* *Delete*、*After* *Delete*

使用场景：

可以通过数据库中的相关表实现级联更改

实时监控表中字段的更改做出相应处理

注意：滥用会造成数据库及应用程序的维护困难 

# 为什么说*B*+树比*B*树更适合数据库索引

1. *B*+树的磁盘读写代价更低：*B*+树的内部节点并没有指向关键字具体信息的指针，因此其内部节点相对*B*树更小，盘块所能容纳的关键字数量也越多，一次性读入内存的关键字也就越多，相对*IO*读写次数就降低了。

2. *B*+树的查询效率更加稳定：由于中间节点并不包含内容，而只是叶子结点的索引。所以任何关键字的查找必须走一条从根结点到叶子结点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。

3. 由于*B*+树的数据都存储在叶子结点中，分支结点均为索引，只需要扫一遍叶子结点即可，但是*B*树因为其分支结点同样存储着数据，我们要找到具体的数据，需要进行一次中序遍历按序来扫，所以*B*+树更加适合在区间查询的情况，所以通常*B*+树用于数据库索引。

# 事务

事务是应用程序中一系列严密的操作，所有操作必须成功完成，否则在每个操作中所作的所有更改都会被撤消。也就是事务具有原子性，一个事务中的一系列的操作要么全部成功，要么一个都不做。

## 事务的四大特性

​	数据库事务 *transanction* 正确执行的四个基本要素。*ACID*,原子性(*Atomicity*)、一致性(*Correspondence*)、隔离性(*Isolation*)、持久性(*Durability*)。

### 原子性

整个事务中的所有操作，要么全部完成，要么全部不完成，不可能停滞在中间某个环节。事务在执行过程中发生错误，会被回滚（*Rollback*）到事务开始前的状态，就像这个事务从来没有执行过一样。

### 一致性

在事务开始之前和事务结束以后，数据库的完整性约束没有被破坏。

拿转账来说，假设用户*A*和用户*B*两者的钱加起来一共是5000，那么不管*A*和*B*之间如何转账，转几次账，事务结束后两个用户的钱相加起来应该还得是5000，这就是事务的一致性。

### 隔离性

隔离性是当多个用户并发访问数据库时，比如操作同一张表时，数据库为每一个用户开启的事务，不能被其他事务的操作所干扰，多个并发事务之间要相互隔离，每个事务都感觉不到有其他事务在并发地执行。

### 持久性

在事务完成以后，该事务所对数据库所作的更改便持久的保存在数据库之中，并不会被回滚。

## 使用场景

1. 实际的业务中，需要将一条数据同事存放到两张表中， 并且要求两张表中的数据同步，那么此时就需要使用事务管理机制，保证数据同步。如果出现错误情况，比如表一插入数据成功，表二插入数据失败，那么就回滚，终止数据持久化操作。
2. 金融行业的软件开发严格重视事务处理，比如我们常见的转账操作，一方的账户金额减少，对应的是另一方的账户金额增加，这个过程需要使用到事务机制，不然转账不能成功

# *MVCC*

多版本并发控制

*innodb*会为每一行添加两个字段，分别表示该行创建的版本和删除的版本，填入的是事务的版本号，这个版本号随着事务的创建不断递增。

*select*：满足以下两个条件*innodb*会返回该行数据：（1）该行的创建版本号小于等于当前事务版本号，用于保证在*select*操作之前所有的操作已经执行落地。（2）行的删除版本要么未定义,要么大于当前事务版本号,这可以确保事务读取到的行，在事务开始之前未被删除。

 *insert*：将新插入的行的创建版本号设置为当前事务版本号。

 *delete*：将要删除的行的删除版本号设置为当前事务版本号。

 *update*：不执行原地*update*，而是转换成*insert* + *delete*。将旧行的删除版本号设置为当前事务版本号，并将新行*insert*同时设置创建版本号为当前事务版本号。

 其中，写操作（*insert*、*delete*和*update*）执行时，需要将事务版本号递增。

 由于旧数据并不真正的删除，所以必须对这些数据进行清理，*innodb*会开启一个后台线程执行清理工作，具体的规则是将删除版本号小于当前系统版本的行删除，这个过程叫做*purge*。

# *sql*语句执行过程

1. 客户端通过连接器连接到*MySQL*服务器

2. 连接器权限验证通过之后，先查询是否有缓存，如果有缓存（之前执行过该条语句）则返回缓存数据，如果不存在缓存数据则进入分析器

3. 分析器会对查询语句进行语法分析和词法分析，以判断*sql*语法是否正确，如果查询语句语法错误直接返回客户端错误信息，如果正确则进入优化器

4. 优化器会对查询语句进行优化处理，比如一个表中存在多个索引，优化器会比较判别哪个索引性能更好

5. 优化器执行完就进入执行器，执行器就开始时执行查询语句进行查询比对了，直到查询到满足条件的所有数据，然后返回数据。

# *truncate*与*drop*、*delete*的对比

*truncate*与*drop*是*DDL*语句，执行后无法回滚；*delete*是*DML*语句，可回滚。

*truncate*只能作用于表；*delete*，*drop*可作用于表、视图等。

*truncate*会清空表中的所有行，但表结构及其约束、索引等保持不变；*drop*会删除表的结构及其所依赖的约束、索引等。

*truncate*会重置表的自增值；*delete*不会。

*truncate*不会激活与表有关的删除触发器；*delete*可以。

*truncate*后会使表和索引所占用的空间会恢复到初始大小；*delete*操作不会减少表或索引所占用的空间，*drop*语句将表所占用的空间全释放掉。

# 聚簇索引、回表查询与覆盖索引

聚簇索引就是按照每张表的主键构造一颗*B+*树，同时叶子节点中存放的是对应的数据行（*InnoDb*必须要有聚簇索引且仅有一个聚簇索引）。

- 如果定义了*PK*，那*PK*就是聚簇索引。
- 如果没有定义*PK*，那*NOT NULL UNIQUE*列就是聚簇索引
- 否则*InnoDb*会创建一个隐藏的*row-id*列做为聚簇索引。

回表查询就是查询普通索引，找到对应的主键值，然后再到聚簇索引里查询主键值对应的行记录，即**先定位主键值，再定位行记录，它的性能较扫一遍索引树更低。**

通过建立复合索引覆盖被查询的字段，直接在查询索引时就获得需要的数据，无需回表。通常是一个索引包含了（或覆盖了）满足查询语句中字段与条件。不是所有类型的索引都可以成为覆盖索引。覆盖索引必须要存储索引的列，而哈希索引、空间索引和全文索引等都不存储索引列的值，所以*MySQL*只能使用*B-Tree*索引做覆盖索引

# 行锁、间隙锁、*next-key*锁

## 行锁(*Record Lock*)

对主键或者唯一索引进行增删改或显示的加锁，*InnoDB*会加行锁,如：

```sql
显式的加锁
select * from  people where id = 3 for update;
```

```sql
update people set name = 'James' where id = 3;
```


注意：

正常的查询语句使用的是共享锁。

对于显示的加锁或增删改操作，条件判断必须是精确匹配（也就是=） ，不能用>,<,*between*或*like*等范围查询方式，因为这样会使行锁变成*next-key*锁。

## 间隙锁(*Gap Lock*)

锁住整个区间，包括：区间里具体的索引记录，不存在的空闲空间（可以是两个索引记录之间，也可能是第一个索引记录之前或最后一个索引记录之后的空间）。

对于间隙锁，什么叫锁住不存在的空闲空间，举个例子：

一个表有*id*为1，2，3，5，6，9行数据，执行如下sql语句

```sql
select * from people where id > 3 AND id < 7 for update;
```

这是一个范围检索，*InnoDB*不仅会锁住*id*为5和6两行的数据，也会锁住*id*为4(虽然该行并不存在)的纪录。

## *next-key*锁

> 官方文档描述：*Record Lock+Gap Lock*，如果一个事务在记录*R*上的某个索引有共享/互斥锁,也会对其前面一个范围加锁

锁定的区域：根据索引会形成左开右闭的一个区间，根据查询条件的其所在的区间，并且**包括其后的区间**。

|  id  | name | age  |
| :--: | :--: | :--: |
|  1   |  a   |  37  |
|  2   |  b   |  28  |
|  3   |  c   |  34  |

如果age是索引的话，相关的区域有
(-∞,28]、(28,34]、(34,37]、(37,+∞)

如果执行如下语句：

```sql
select * from  people where age = 34 for update;
```

那么会锁住(28,37]这个范围

如果执行如下语句：

```sql
select * from  people where age = 33 for update;
```

那么会锁住(28,34)这个范围

间隙锁的目的是为了防止幻读，其主要通过两个方面实现这个目的：

1. 防止间隙内有新数据被插入
2. 防止已存在的数据，更新成间隙内的数据

*innodb*自动使用间隙锁的条件：

1. 必须在*Repeatable Read*级别下
2. 检索条件必须有普通索引（没有索引的话，*mysql*会全表扫描，那样会锁定整张表所有的记录，包括不存在的记录）

**注意：这里的普通索引不包括主键索引和唯一索引，如果在这两个索引下因为能精确检索出结果，所以会使用*Record Lock*直接锁定具体的行（范围查询除外）。**

# 切分

## 水平切分

水平切分又称为 *Sharding*，它是将同一个表中的记录拆分到多个结构相同的表中。

当一个表的数据不断增多时，*Sharding* 是必然的选择，它可以将数据分布到集群的不同节点上，从而缓存单个数据库的压力。

## 垂直切分

垂直切分是将一张表按列切分成多个表，通常是按照列的关系密集程度进行切分，也可以利用垂直切分将经常被使用的列和不经常被使用的列切分到不同的表中。

在数据库的层面使用垂直切分将按数据库中表的密集程度部署到不同的库中，例如将原来的电商数据库垂直切分成商品数据库、用户数据库等。

# 复制

## 主从复制

主要涉及三个线程：*binlog* 线程、*I/O* 线程和 *SQL* 线程。

- *binlog* 线程 ：负责将主服务器上的数据更改写入二进制日志（*Binary log*）中。
- *I/O* 线程 ：负责从主服务器上读取二进制日志，并写入从服务器的中继日志（*Relay log*）。
- *SQL* 线程 ：负责读取中继日志，解析出主服务器已经执行的数据更改并在从服务器中重放（*Replay*）。

## 读写分离

主服务器处理写操作以及实时性要求比较高的读操作，而从服务器处理读操作。

读写分离能提高性能的原因在于：

- 主从服务器负责各自的读和写，极大程度缓解了锁的争用；
- 从服务器可以使用 *MyISAM*，提升查询性能以及节约系统开销；
- 增加冗余，提高可用性。

读写分离常用代理方式来实现，代理服务器接收应用层传来的读写请求，然后决定转发到哪个服务器。
